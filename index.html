<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ChatGPT â†’ Smart Markdown â†’ PDF (client-side)</title>

  <!-- EasyMDE CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <style>
    :root{--accent:#2b8aef;--bg:#f7f9fb}
    body{font-family:Inter,ui-sans-serif,system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; background:var(--bg); color:#111;}
    header{display:flex;gap:1rem;align-items:center;padding:1rem;background:#fff;border-bottom:1px solid #eee}
    header h1{font-size:1.05rem;margin:0}
    .container{display:grid;grid-template-columns:1fr 1fr;gap:1rem;padding:1rem;}
    .controls{display:flex;color: black;gap:.5rem;flex-wrap:wrap}
    button{background:var(--accent);color:white;border:0;padding:.55rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;color:var(--accent);border:1px solid #d9e7ff}
    .panel{background:#fff;border-radius:8px;padding:1rem;box-shadow:0 6px 18px rgba(20,30,60,0.04)}
    .panel h2{margin-top:0;font-size:.95rem}
    #preview{padding:1rem;max-height:60vh;overflow:auto;border:1px solid #f0f0f0;border-radius:6px;background:#fff}
    .top-controls{display:flex;color: black;gap:.5rem;align-items:center}
    input[type=file]{display:none}
    .small{padding:.35rem .5rem;font-size:.9rem}
    footer{padding:1rem;text-align:center;color:#666;font-size:.9rem}
    @media (max-width:900px){.container{grid-template-columns:1fr}}
  </style>
</head>
<body>

<header>
  <h1>ChatGPT â†’ Smart Markdown â†’ PDF</h1>
  <div style="flex:1"></div>
  <div class="controls">
    <button id="btnAutoPaste" title="Read text from clipboard (requires permission)">Auto-paste</button>
    <label for="fileTxt" class="ghost small" style="cursor:pointer;padding:.4rem .6rem;border-radius:6px;border:1px solid #ddd;">Upload .txt</label>
    <input id="fileTxt" type="file" accept=".txt,text/plain" />
    <button id="btnSuggest" class="small ghost">Smart Suggest</button>
    <button id="btnReset" class="small ghost">Reset</button>
  </div>
</header>

<div class="container">
  <div class="panel">
    <h2>Editor</h2>
    <textarea style="max-height: 70vh; color: black;" id="editorTextarea" placeholder="Paste ChatGPT output here..."></textarea>

    <div style="margin-top:.7rem;display:flex;gap:.5rem;align-items:center">
      <button id="btnDownloadMD" class="small">Download .md</button>
      <button id="btnDownloadPDF" class="small">Download .pdf</button>
      <button id="btnCopyMD" class="small ghost">Copy Markdown</button>
      <div style="flex:1"></div>
      <span style="color:#666;font-size:.9rem">Tip: run <strong>Smart Suggest</strong> then edit.</span>
    </div>
  </div>

  <div class="panel">
    <h2>Live Preview</h2>
    <div id="preview" aria-live="polite"></div>
  </div>
</div>

  
  <h1>Version 2</h1>
  <a href="version2.html">click here</a>

<footer>
  This runs fully in your browser â€” no server. Smart-suggest is heuristic and may need editing.
</footer>

<!-- Libraries (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<script>
/*
  Main features:
  - EasyMDE editor for live editing (left)
  - marked to render preview (right)
  - SmartSuggest: front-end heuristic to turn plain text into markdown
  - Auto-paste from clipboard (user gesture required)
  - Upload .txt
  - Download .md (FileSaver) and .pdf (html2pdf from preview)
*/

/* ---------- Init editor ---------- */
const easyMDE = new EasyMDE({
  element: document.getElementById('editorTextarea'),
  autofocus: false,
  spellChecker: false,
  status: false,
  toolbar: ["bold","italic","heading","|","quote","unordered-list","ordered-list","code","link","image","|","preview","side-by-side","fullscreen"],
  autoDownloadFontAwesome: false,
  minHeight: "36vh"
});

/* ---------- Preview rendering ---------- */
const preview = document.getElementById('preview');
function renderPreview(md){
  // marked options: sanitize is false to allow code/media; if you want stricter, enable sanitizer.
  preview.innerHTML = marked.parse(md || "");
}
easyMDE.codemirror.on("change", () => {
  renderPreview(easyMDE.value());
});

/* ---------- Smart Suggest (heuristic transformer) ---------- */
function isAllCapsLine(s){
  // consider a line heading if it's shorter than 80 chars and has many uppercase letters
  const letters = s.replace(/[^A-Za-z]/g,"");
  if (!letters) return false;
  const upper = letters.replace(/[^A-Z]/g,"");
  return upper.length / letters.length > 0.6 && s.trim().length > 1 && s.trim().length < 80;
}

function looksLikeCodeLine(s){
  // a simple test: typical code features
  return /[{;}=>\(\)\[\]]/.test(s) || /\b(function|const|let|var|if|else|for|while|return|class)\b/.test(s) || /^\s{2,}/.test(s);
}

function smartSuggestTransform(raw){
  raw = raw.replace(/\r\n/g,"\n").trim();
  const lines = raw.split("\n");
  const out = [];
  let i = 0;

  // helpers
  const isBlank = s => !s || s.trim() === "";
  const startsWithEmoji = s => /^[\p{Emoji}\u2600-\u27BF]/u.test(s.trim());
  const looksLikeCodeLine = s => /[{;}=>\(\)\[\]]/.test(s) || /\b(function|const|let|var|int|float|double|cout|cin|return|for|while|do|if|else|switch|case)\b/.test(s) || /^\s{2,}/.test(s);
  const isTableRow = s => /\|/.test(s) || (/\t/.test(s) && s.split(/\t/).length>1);
  const isSeparatorLine = s => /^-{3,}\s*$/.test(s) || /^â€”{3,}\s*$/.test(s) || /^\*\*\*+\s*$/.test(s);

  // convert a block of consecutive code-like lines into fenced code block
  const flushAsCode = (block) => {
    if(block.length === 0) return;
    // try to detect language (simple check for cpp keywords)
    const lang = block.some(l => /\b(int|cout|cin|endl|#include|using namespace|std::)\b/.test(l)) ? "cpp" : "";
    out.push("```" + lang);
    out.push(...block);
    out.push("```");
  };

  while(i < lines.length){
    const L = lines[i];

    // explicit horizontal rule
    if(isSeparatorLine(L) || /^\s*---\s*$/.test(L)){
      out.push("");
      out.push("---");
      out.push("");
      i++; continue;
    }

    // skip leading/trailing whitespace-only lines but keep single blank line
    if(isBlank(L)){
      out.push("");
      i++; 
      continue;
    }

    // Table detection: if current line is a table header and next line is a separator with dashes or pipes
    if(isTableRow(L)){
      // collect consecutive table-like lines
      const tableBlock = [];
      while(i < lines.length && (isTableRow(lines[i]) || isBlank(lines[i]))) {
        if(!isBlank(lines[i])) tableBlock.push(lines[i].trim());
        i++;
      }
      // Normalize tab-separated rows to pipe table
      const rows = tableBlock.map(r => {
        if(r.includes("|")) return r;
        const cols = r.split(/\t+/).map(c=>c.trim());
        return "| " + cols.join(" | ") + " |";
      });

      // If header present without separator, try to add separator line
      if(rows.length >= 2 && !/^\|?\s*[:-]+/.test(rows[1])){
        // if second row is not a markdown separator but looks like dashes, convert
        // else insert a separator with default alignment
        const headers = rows[0].split("|").filter(Boolean).map(h=>h.trim());
        const sep = "| " + headers.map(()=> "---").join(" | ") + " |";
        out.push(rows[0]);
        out.push(sep);
        for(let r = 1; r < rows.length; r++) out.push(rows[r]);
      } else {
        out.push(...rows);
      }
      out.push("");
      continue;
    }

    // Headings: emoji + text or lines in ALL CAPS (short) or lines ending with 'â€“' or ':' used as heading
    const trimmed = L.trim();
    if(startsWithEmoji(trimmed)){
      // strip leading emoji(s)
      const t = trimmed.replace(/^[\p{Emoji}\u2600-\u27BF]+\s*/u,"").trim();
      out.push("## " + t);
      i++; continue;
    }
    // lines like "ðŸ§© 1. What Are Control Structures?" or "1. What Are..." treat as heading if short
    if(/^\d+\.\s+[A-Z][\s\S]{0,120}$/.test(trimmed) && trimmed.length < 120){
      const text = trimmed.replace(/^\d+\.\s+/,"").trim();
      out.push("## " + text);
      i++; continue;
    }
    // all caps short => heading
    if(/[A-Z0-9\W]+/.test(trimmed) && trimmed === trimmed.toUpperCase() && trimmed.length < 100 && trimmed.split(" ").length <= 8){
      out.push("## " + trimmed);
      i++; continue;
    }
    // lines that end with ":" and are short -> subheading
    if(/:\s*$/.test(trimmed) && trimmed.split(/\s+/).length <= 8){
      out.push("### " + trimmed.replace(/:\s*$/,""));
      i++; continue;
    }

    // Example blocks: "Example", "Examples", "Coding Practice", "Practice Questions"
    if(/^\s*(Example|Examples|Coding Practice|Practice Questions|Practice):?/i.test(trimmed)){
      const heading = trimmed.replace(/:$/,"").trim();
      out.push("### " + heading);
      // collect following non-empty lines until blank or next major heading indicator
      i++;
      const buff = [];
      while(i < lines.length && !isBlank(lines[i]) && !/^[\p{Emoji}\u2600-\u27BF]/u.test(lines[i]) && !/^\d+\.\s+[A-Z]/.test(lines[i])){
        buff.push(lines[i]);
        i++;
      }
      // If buff contains code-like lines, wrap as fenced code, else as blockquote or list
      if(buff.some(ln => looksLikeCodeLine(ln) || /;/.test(ln))){
        // if they appear to be several code samples, split by blank lines
        const blocks = buff.join("\n").split(/\n\s*\n/);
        blocks.forEach(b=>{
          if(looksLikeCodeLine(b) || /;/.test(b)) {
            out.push("```cpp");
            out.push(...b.split("\n").map(x=>x));
            out.push("```");
          } else {
            b.split("\n").forEach(x => out.push("> " + x));
          }
        });
      } else {
        buff.forEach(ln => out.push("> " + ln));
      }
      out.push("");
      continue;
    }

    // Numbered lists and bullet lists detection
    if(/^\s*\d+[\.\)]\s+/.test(L) || /^\s*[-\*\u2022]\s+/.test(L)){
      // collect contiguous list lines
      const listLines = [];
      while(i < lines.length && (/^\s*\d+[\.\)]\s+/.test(lines[i]) || /^\s*[-\*\u2022]\s+/.test(lines[i]) || /^\s{4,}/.test(lines[i]))){
        // preserve indentation for nested lists
        listLines.push(lines[i].replace(/\u2022/,"-"));
        i++;
      }
      out.push(...listLines.map(s => s.trim()));
      out.push("");
      continue;
    }

    // Code block detection: group contiguous code-like lines
    if(looksLikeCodeLine(L)){
      const codeBuf = [];
      while(i < lines.length && (looksLikeCodeLine(lines[i]) || lines[i].trim()==="")){
        if(lines[i].trim() !== "") codeBuf.push(lines[i]);
        i++;
      }
      flushAsCode(codeBuf);
      out.push("");
      continue;
    }

    // Summary table like "Structure\tKeyword\tWhen to Use" => convert to markdown table
    if(/Structure\s+Keyword\s+When to Use/i.test(L)){
      // collect rows until blank
      const rows = [];
      while(i < lines.length && !isBlank(lines[i])){
        rows.push(lines[i]);
        i++;
      }
      // parse rows splitting by tabs or multiple spaces
      const parsed = rows.map(r => r.split(/\t+| {2,}/).map(c=>c.trim()).filter(Boolean));
      // write as markdown table
      const header = parsed[0];
      out.push("| " + header.join(" | ") + " |");
      out.push("| " + header.map(()=> "---").join(" | ") + " |");
      for(let r = 1; r < parsed.length; r++){
        out.push("| " + parsed[r].join(" | ") + " |");
      }
      out.push("");
      continue;
    }

    // Fallback: paragraph text. Merge consecutive non-empty lines into a paragraph until blank or heading
    const para = [];
    while(i < lines.length && !isBlank(lines[i]) && !isTableRow(lines[i]) && !isSeparatorLine(lines[i]) && !/^\s*#{1,6}\s+/.test(lines[i])){
      // stop if next line looks like a heading (all caps or emoji)
      if(i+1 < lines.length && (lines[i+1].trim() === "")) {
        para.push(lines[i].trim());
        i++;
        break;
      }
      // break if next is explicit heading-like
      if(lines[i+1] && (lines[i+1].trim() === lines[i+1].trim().toUpperCase() && lines[i+1].trim().length < 80) ) {
        para.push(lines[i].trim());
        i++;
        break;
      }
      para.push(lines[i].trim());
      i++;
    }
    out.push(para.join(" "));
    out.push("");
  }

  // final cleanup: remove excessive blank lines
  return out.join("\n").replace(/\n{3,}/g,"\n\n").trim();
}

/* ---------- Buttons & interactions ---------- */
document.getElementById('btnAutoPaste').addEventListener('click', async ()=>{
  try {
    // Clipboard API needs user gesture - handled here by click
    const text = await navigator.clipboard.readText();
    if(!text){
      alert("Clipboard is empty or contains non-text.");
      return;
    }
    easyMDE.value(text);
    renderPreview(text);
    // scroll to editor
    easyMDE.codemirror.focus();
  } catch(err){
    console.error(err);
    alert("Could not read clipboard. Browsers require permission and a secure context (https). Try pasting manually (Ctrl+V) or upload a .txt file.");
  }
});

// File upload
document.getElementById('fileTxt').addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  if(f.type && !f.type.startsWith("text")) {
    // still try to read if extension is .txt
  }
  try {
    const txt = await f.text();
    easyMDE.value(txt);
    renderPreview(txt);
  } catch(err){
    alert("Failed to read file: " + err);
  }
});

// Smart Suggest
document.getElementById('btnSuggest').addEventListener('click', ()=>{
  const raw = easyMDE.value();
  if(!raw.trim()){
    alert("Editor is empty. Paste or upload ChatGPT output first.");
    return;
  }
  const md = smartSuggestTransform(raw);
  easyMDE.value(md);
  renderPreview(md);
});

// Reset (clears editor and preview)
document.getElementById('btnReset').addEventListener('click', ()=>{
  if(!confirm("Clear the editor and preview?")) return;
  easyMDE.value("");
  renderPreview("");
});

// Download .md
document.getElementById('btnDownloadMD').addEventListener('click', ()=>{
  const md = easyMDE.value() || "";
  const blob = new Blob([md], {type: "text/markdown;charset=utf-8"});
  saveAs(blob, "document.md");
});

// Copy Markdown to clipboard
document.getElementById('btnCopyMD').addEventListener('click', async ()=>{
  try {
    await navigator.clipboard.writeText(easyMDE.value());
    alert("Markdown copied to clipboard.");
  } catch(err){
    console.error(err);
    alert("Unable to copy to clipboard. Try selecting and copying manually.");
  }
});

// Download PDF from preview
document.getElementById('btnDownloadPDF').addEventListener('click', async ()=>{
  // Make sure preview is up-to-date
  renderPreview(easyMDE.value());
  // A little styling wrapper for PDF (optional)
  const opt = {
    margin:       10,
    filename:     'document.pdf',
    image:        { type: 'jpeg', quality: 0.98 },
    html2canvas:  { scale: 2, useCORS: true },
    jsPDF:        { unit: 'mm', format: 'a4', orientation: 'portrait' }
  };
  // Use html2pdf on preview element
  html2pdf().set(opt).from(preview).save();
});

/* initial render */
renderPreview(easyMDE.value());
</script>
</body>
